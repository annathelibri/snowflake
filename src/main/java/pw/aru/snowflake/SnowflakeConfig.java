package pw.aru.snowflake;

import pw.aru.snowflake.entities.SnowflakeDatacenter;
import pw.aru.snowflake.entities.SnowflakeGenerator;
import pw.aru.snowflake.entities.SnowflakeWorker;

import java.time.OffsetDateTime;
import java.util.Calendar;
import java.util.TimeZone;

/**
 * <p>The configuration (read-only) of a Snowflake,
 * used to describe the snowflake structure of a ID generated by a specific {@link SnowflakeWorker}.</p>
 *
 * <p>It's value is shared for all {@link SnowflakeWorker}s and {@link SnowflakeDatacenter}s of a
 * specific {@link SnowflakeGenerator}.</p>
 *
 * <p>Its common uses are to check the validness of a specific {@link SnowflakeGenerator} setup ({@link SnowflakeConfig#isValid()})
 * and to get the creation time ({@link SnowflakeConfig#getCreationTime(long)}) of a snowflake.</p>
 */
public class SnowflakeConfig {

    private static OffsetDateTime convert(long millis) {
        Calendar gmt = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        gmt.setTimeInMillis(millis);
        return OffsetDateTime.ofInstant(gmt.toInstant(), gmt.getTimeZone().toZoneId());
    }

    /**
     * How much of the Snowflake is occupied by the Datacenter ID, in bits.
     */
    public final long datacenterIdBits;
    /**
     * The value used for datacenter id-based shifts.
     */
    public final long datacenterIdShift;
    /**
     * The base Epoch of the Snowflake.
     */
    public final long epoch;
    /**
     * The maximum ID possible for a datacenter.
     */
    public final long maxDatacenterId;
    /**
     * The maximum ID possible for a worker.
     */
    public final long maxWorkerId;
    /**
     * How much of the Snowflake is occupied by the Sequencial ID, in bits.
     */
    public final long sequenceBits;
    /**
     * The mask used to get only the sequence bits.
     */
    public final long sequenceMask;
    /**
     * How much of the Snowflake is occupied by the timestamp of the ID, in bits.
     */
    public final long timestampBits;
    /**
     * The value used for timestamp-based shifts.
     */
    public final long timestampShift;
    /**
     * How much of the Snowflake is occupied by the Worker ID, in bits.
     */
    public final long workerIdBits;
    /**
     * The value used for worker id-based shifts.
     */
    public final long workerIdShift;
    /**
     * The expiration date of this Config, in milliseconds.
     */
    private final long expirationDateMillis;

    /**
     * Creates a new Config.
     *
     * @param epoch            The base Epoch of the Snowflake.
     * @param datacenterIdBits How much of the Snowflake is occupied by the Datacenter ID, in bits.
     * @param workerIdBits     How much of the Snowflake is occupied by the Worker ID, in bits.
     * @param sequenceBits     How much of the Snowflake is occupied by the Sequencial ID, in bits.
     */
    public SnowflakeConfig(long epoch, long datacenterIdBits, long workerIdBits, long sequenceBits) {
        // Parameter checks
        if (epoch < 0)
            throw new IllegalArgumentException("epoch must be positive");

        if (epoch > System.currentTimeMillis())
            throw new IllegalArgumentException("epoch is on the future");

        if (datacenterIdBits < 0)
            throw new IllegalArgumentException("datacenterIdBits must be positive");

        if (workerIdBits < 0)
            throw new IllegalArgumentException("workerIdBits must be positive");

        if (sequenceBits < 0)
            throw new IllegalArgumentException("sequenceBits must be positive");

        if ((datacenterIdBits + workerIdBits + sequenceBits) >= Long.SIZE)
            throw new IllegalArgumentException("(datacenterIdBits + workerIdBits + sequenceBits) need to be under " + Long.SIZE + " bits.");

        // Parameters
        this.epoch = epoch;
        this.datacenterIdBits = datacenterIdBits;
        this.sequenceBits = sequenceBits;
        this.workerIdBits = workerIdBits;

        // Bitshifts
        workerIdShift = sequenceBits;
        datacenterIdShift = workerIdShift + workerIdBits;
        timestampShift = datacenterIdShift + datacenterIdBits;

        // Other values
        timestampBits = Long.SIZE - timestampShift;
        sequenceMask = ~(-1L << this.sequenceBits);
        maxDatacenterId = ~(-1L << this.datacenterIdBits);
        maxWorkerId = ~(-1L << this.workerIdBits);
        expirationDateMillis = epoch + (2L << (Long.SIZE - timestampShift));
    }

    /**
     * Creates a new Config with the "default" values for bits.
     * <table border=1>
     * <tr>
     * <th>Parameter</th>
     * <th>Value</th>
     * </tr>
     * <tr>
     * <td>Epoch</td>
     * <td>&lt;parameter&gt;</td>
     * </tr>
     * <tr>
     * <td>datacenterIdBits</td>
     * <td>5</td>
     * </tr>
     * <tr>
     * <td>workerIdBits</td>
     * <td>5</td>
     * </tr>
     * <tr>
     * <td>sequenceBits</td>
     * <td>12</td>
     * </tr>
     * </table>
     *
     * @param epoch The base Epoch of the Snowflake.
     */
    public SnowflakeConfig(long epoch) {
        this(epoch, 5, 5, 12);
    }

    public String toString() {
        return String.format(
            "SnowflakeConfig[epoch=%d, timestampBits=%d, datacenterIdBits=%d,  workerIdBits=%d, sequenceBits=%d, valid=%s]",
            this.epoch, (Long.SIZE - timestampShift), this.datacenterIdBits, this.workerIdBits, this.sequenceBits, isValid()
        );
    }

    private SnowflakeConfig checkValid() {
        if (!isValid()) throw new IllegalStateException("the config already expired. can't generate new Snowflakes.");
        return this;
    }

    public OffsetDateTime getCreationTime(long snowflake) {
        return convert(getCreationTimeMillis(snowflake));
    }

    public long getCreationTimeMillis(long snowflake) {
        return (snowflake >> timestampShift) + epoch;
    }

    public OffsetDateTime getExpirationDate() {
        return convert(expirationDateMillis);
    }

    public long getTimeRemaining() {
        return expirationDateMillis - System.currentTimeMillis();
    }

    public boolean isValid() {
        return getTimeRemaining() >= 0;
    }
}
